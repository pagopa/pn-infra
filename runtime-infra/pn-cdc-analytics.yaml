AWSTemplateFormatVersion: '2010-09-09'
Description: Create base resources for CDC files analysis

Parameters:
  ProjectName:
    Type: String
    Default: pn
    Description: Base name for pn project
  LogsBucketName:
    Type: String
    Description: Logs bucket name
  BucketSuffix:
    Type: String
    Description: Suffix for the athena result bucket name
  LogsBucketKmsKeyArn:
    Type: String
    Description: Arn of logs bucket KMS key

Resources:
  GlueServiceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - glue.amazonaws.com
            Action:
              - sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSGlueServiceRole
      Policies:
        - PolicyName: S3Access
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetBucketLocation
                  - s3:ListBucket
                  - s3:GetObject
                Resource:
                  - !Sub arn:aws:s3:::${LogsBucketName}
                  - !Sub arn:aws:s3:::${LogsBucketName}/*
        - PolicyName: S3EncryptionAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetEncryptionConfiguration
                Resource:
                  - !Sub arn:aws:s3:::${LogsBucketName}
        - PolicyName: KMSEncryptionAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - kms:Decrypt
                  - kms:DescribeKey
                Resource:
                  - !Ref LogsBucketKmsKeyArn

  AthenaWorkGroup:
    Type: AWS::Athena::WorkGroup
    DependsOn: GlueServiceRole
    Properties:
      Name: cdc_analytics_workgroup
      Description: Workgroup for querying data in Athena
      State: ENABLED
      WorkGroupConfiguration:
        ResultConfiguration:
          OutputLocation: !Sub s3://${AthenaResultsBucket}/

  GlueDatabase:
    Type: AWS::Glue::Database
    DependsOn: AthenaWorkGroup
    Properties:
      CatalogId: !Ref AWS::AccountId
      DatabaseInput:
        Name: cdc_analytics_database

  AthenaResultsBucket:
    Type: AWS::S3::Bucket
    DeletionPolicy: Retain
    UpdateReplacePolicy: Retain
    Properties:
      BucketName: !Sub ${ProjectName}-cdc-analytics-athena-results-${AWS::Region}-${AWS::AccountId}-${BucketSuffix}
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true

  AthenaResultsBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref AthenaResultsBucket
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: athena.amazonaws.com
            Action:
              - s3:PutObject
              - s3:GetObject
            Resource:
              - !Sub arn:aws:s3:::${AthenaResultsBucket}/*
            Condition:
              StringEquals:
                aws:SourceAccount: !Ref AWS::AccountId
          - Effect: Allow
            Principal:
              Service: athena.amazonaws.com
            Action:
              - s3:ListBucket
            Resource:
              - !Sub arn:aws:s3:::${AthenaResultsBucket}
            Condition:
              StringEquals:
                aws:SourceAccount: !Ref AWS::AccountId

  ###############################################################################
  ###                       UPDATE CDC JSON VIEWS CACHE                       ###
  ###############################################################################

  UpdateCdcJsonViewsLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: PnAthenaUpdateCdcJsonCache
      Description: Updates CDC JSON cache tables based on views
      Runtime: python3.11
      Handler: index.lambda_handler
      MemorySize: 256
      Timeout: 900 # 15 minutes (maximum lambda timeout)
      Role: !GetAtt UpdateCdcJsonViewsLambdaRole.Arn
      Environment:
        Variables:
          REGION: !Ref AWS::Region
          ACCOUNT_ID: !Ref AWS::AccountId
          DATABASE_NAME: !Ref GlueDatabase
          ATHENA_OUTPUT_BUCKET: !Ref AthenaResultsBucket
      Code:
        ZipFile: |
          import boto3, json, time, os, logging
          from datetime import datetime, timedelta
          from concurrent.futures import ThreadPoolExecutor
          from zoneinfo import ZoneInfo

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          region = os.environ.get('REGION')
          account_id = os.environ.get('ACCOUNT_ID')
          database_name = os.environ.get('DATABASE_NAME')
          athena_output_bucket = os.environ.get('ATHENA_OUTPUT_BUCKET')

          def execute_query(data, reference_date, start_time, timeout=880):
              """Execute and monitor Athena query with timeout handling"""
              athena = boto3.client('athena', region_name=region)
              
              # Build date condition and query
              date_filter = f"p_year = lpad(cast(year(date('{reference_date}')) as varchar), 4, '0') " + \
                          f"AND p_month = lpad(cast(month(date('{reference_date}')) as varchar), 2, '0') " + \
                          f"AND p_day = lpad(cast(day(date('{reference_date}')) as varchar), 2, '0')"
              
              query = f"INSERT INTO \"{database_name}\".\"{data['cache']}\" " + \
                    f"(SELECT * FROM \"{database_name}\".\"{data['view']}\" WHERE {date_filter} " + \
                    f"EXCEPT SELECT * FROM \"{database_name}\".\"{data['cache']}\" WHERE {date_filter})"
              
              # Start query and get execution ID
              resp = athena.start_query_execution(
                  QueryString=query,
                  ResultConfiguration={'OutputLocation': f"s3://{athena_output_bucket}/cache_updates/{data['cache']}"}
              )
              qid = resp['QueryExecutionId']
              result = {'table': data['cache'], 'id': qid}
              
              # Monitor until completion or timeout
              while True:
                  # Check for Lambda timeout
                  elapsed = time.time() - start_time
                  if elapsed > timeout:
                      logger.warning(f"TIMEOUT: Query {qid} for {data['cache']}")
                      return {'table': data['cache'], 'id': qid, 'state': 'TIMEOUT', 'time': elapsed}
                      
                  # Check query status
                  status = athena.get_query_execution(QueryExecutionId=qid)['QueryExecution']['Status']['State']
                  
                  if status == 'SUCCEEDED':
                      logger.info(f"Success: {data['cache']} in {time.time() - start_time:.1f}s")
                      return {'table': data['cache'], 'id': qid, 'state': 'SUCCESS', 'time': elapsed}
                  
                  if status in ['FAILED', 'CANCELLED']:
                      error = athena.get_query_execution(QueryExecutionId=qid)['QueryExecution']['Status'].get('StateChangeReason', 'Unknown')
                      logger.error(f"Failed: {data['cache']} - {error}")
                      return {'table': data['cache'], 'id': qid, 'state': 'FAILED', 'error': error, 'time': elapsed}
                  
                  time.sleep(2)

          def log_errors(failures, timeouts):
              """Log failures and timeouts"""
              if not failures and not timeouts:
                  return
                  
              logger.warning(f"=== CDC JSON CACHE UPDATE ERRORS: {len(failures)} failures, {len(timeouts)} timeouts ===")
              
              # Log failures
              for f in failures:
                  logger.error(f"FAILED: table={f['table']}, query={f['id']}, error={f.get('error', 'Unknown')}")
              
              # Log timeouts
              for t in timeouts:
                  logger.warning(f"TIMEOUT: table={t['table']}, query={t['id']}")

          def lambda_handler(event, context):
              start_time = time.time()
              
              # get reference date (yesterday in Europe/Rome timezone) or from event
              reference_date = event.get('date') or (datetime.now(ZoneInfo('Europe/Rome')) - timedelta(days=1)).strftime('%Y-%m-%d')
              logger.info(f"Reference date: {reference_date}")
              
              # get crawlers with PnHasView tag
              glue = boto3.client('glue', region_name=region)
              crawlers = glue.list_crawlers(Tags={'PnHasView': 'true'}, MaxResults=100).get('CrawlerNames', [])
              
              if not crawlers:
                  logger.info("No crawlers with PnHasView tag found")
                  return {'statusCode': 200, 'body': json.dumps({'message': 'No crawlers to process'})}
              
              # get view-cache pairs from crawler tags
              queries = []
              for crawler in crawlers:
                  tags = glue.get_tags(ResourceArn=f"arn:aws:glue:{region}:{account_id}:crawler/{crawler}")['Tags']
                  if 'PnView' in tags and 'PnViewCache' in tags:
                      queries.append({'view': tags['PnView'], 'cache': tags['PnViewCache']})
              
              # execute max 20 queries parallel
              results = []
              with ThreadPoolExecutor(max_workers=20) as executor:
                  futures = {executor.submit(execute_query, q, reference_date, start_time): q['cache'] for q in queries}
                  for future in futures:
                      try:
                          results.append(future.result())
                      except Exception as e:
                          results.append({'table': futures[future], 'state': 'ERROR', 'error': str(e)})
              
             
              successes = [r for r in results if r.get('state') == 'SUCCESS']
              failures = [r for r in results if r.get('state') == 'FAILED']
              timeouts = [r for r in results if r.get('state') == 'TIMEOUT']
              
              if failures or timeouts:
                  log_errors(failures, timeouts)
              
              total_time = time.time() - start_time
              logger.info(f"Completed: {len(successes)} successes, {len(failures)} failures, {len(timeouts)} timeouts in {total_time:.1f}s")
              
              return {
                  'statusCode': 200,
                  'body': json.dumps({
                      'message': f"Completed in {total_time:.1f}s: {len(successes)} successes, {len(failures)} failures, {len(timeouts)} timeouts",
                      'execution_time': total_time,
                      'results': results
                  })
              }

  UpdateCdcJsonViewsLambdaLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "/aws/lambda/${UpdateCdcJsonViewsLambda}"
      RetentionInDays: 30

  UpdateCdcJsonViewsLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: pn-athena-update-cdc-json-cache-lambda-role
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: pn-athena-update-cdc-json-cache-lambda-policy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Sid: CanListCrawlers
                Effect: Allow
                Action:
                  - "glue:BatchGetCrawlers"
                  - "glue:ListCrawlers"
                  - "glue:GetTags"
                  - "glue:GetTable"
                  - "glue:GetTables"
                  - "glue:GetDatabase"
                  - "glue:GetDatabases"
                Resource: "*"
              - Sid: CanExecuteQuery
                Effect: Allow
                Action:
                  - "athena:BatchGetQueryExecution"
                  - "athena:GetQueryExecution"
                  - "athena:StartQueryExecution"
                Resource: "*"
              - Sid: CanCheckOutputBucketLocation
                Effect: Allow
                Action:
                  - s3:GetBucketLocation
                Resource:
                  - !Sub arn:aws:s3:::${AthenaResultsBucket}
              - Sid: WriteAndReadQueryResult
                Effect: Allow
                Action:
                  - s3:PutObject
                  - s3:GetObject
                Resource:
                  - !Sub arn:aws:s3:::${AthenaResultsBucket}/cache_updates/*
              - Sid: ReadLogBucket
                Effect: Allow
                Action:
                  - s3:GetBucketLocation
                  - s3:GetEncryptionConfiguration
                  - s3:ListBucket
                  - s3:GetObject
                Resource:
                  - !Sub arn:aws:s3:::${LogsBucketName}
                  - !Sub arn:aws:s3:::${LogsBucketName}/*
              - Sid: DecriptLogBucket
                Effect: Allow
                Action:
                  - kms:Decrypt
                  - kms:DescribeKey
                Resource:
                  - !Ref LogsBucketKmsKeyArn
              - Sid: ReadWriteDestination
                Effect: Allow
                Action:
                  - s3:GetBucketLocation
                  - s3:GetEncryptionConfiguration
                  - s3:ListBucket
                  - s3:GetObject
                  - s3:PutObject
                Resource:
                  - !Sub arn:aws:s3:::${AthenaResultsBucket}
                  - !Sub arn:aws:s3:::${AthenaResultsBucket}/cdcTos3_parsed/*
              - Sid: EncryptDecriptDestination
                Effect: Allow
                Action:
                  - kms:Decrypt
                  - kms:Encrypt
                  - kms:GenerateDataKey
                  - kms:ReEncrypt*
                  - kms:DescribeKey
                Resource:
                  - !Ref LogsBucketKmsKeyArn

  UpdateCdcJsonViewsScheduleBridgeRule:
    Type: AWS::Scheduler::Schedule
    Properties: 
      Description: Schedule json views cache update everyday at 01:00 Europe/Rome
      ScheduleExpression: "cron(0 1 * * ? *)"
      ScheduleExpressionTimezone: "Europe/Rome"
      FlexibleTimeWindow:
        Mode: "OFF"
      State: "ENABLED"
      Target:
        Arn: !GetAtt UpdateCdcJsonViewsLambda.Arn
        RoleArn: !GetAtt EventBusRunLambdaRole.Arn
  
  EventBusRunLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Action: sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                - events.amazonaws.com
                - scheduler.amazonaws.com
      Policies:
        - PolicyName: runLambda
          PolicyDocument:
            Statement:
              - Sid: invokeLambda
                Action:
                  - "lambda:InvokeFunction"
                Effect: Allow
                Resource: 
                  - !GetAtt UpdateCdcJsonViewsLambda.Arn

Outputs:
  GlueDatabaseName:
    Description: Name of the Glue Database
    Value: !Ref GlueDatabase
    Export:
      Name: !Sub ${AWS::StackName}-GlueDatabaseName

  GlueDatabaseArn:
    Description: ARN of the Glue Database
    Value: !Sub arn:aws:glue:${AWS::Region}:${AWS::AccountId}:database/${GlueDatabase}
    Export:
      Name: !Sub ${AWS::StackName}-GlueDatabaseArn
  
  GlueServiceRoleArn:
    Description: ARN of the Glue Service Role
    Value: !GetAtt GlueServiceRole.Arn
    Export:
      Name: !Sub "${AWS::StackName}-GlueServiceRoleArn"