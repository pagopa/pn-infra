AWSTemplateFormatVersion: 2010-09-09
Description: Macro used to generate athena views starting from dynamo cdc on s3 bucket


Resources:

  GenerateCdcViewMacro:
    Type: AWS::CloudFormation::Macro
    Properties:
      Description: CloudFormation macro to generate
      FunctionName: !GetAtt GenerateCdcViewFunction.Arn
      Name: GenerateCdcViewMacro
  
  GenerateCdcViewFunctionLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName:
        !Sub [
          "/aws/lambda/${groupName}",
          { groupName: !Ref GenerateCdcViewFunction },
        ]
      RetentionInDays: 14

  GenerateCdcViewFunctionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: [lambda.amazonaws.com]
            Action: ["sts:AssumeRole"]
      Path: /
      Policies:
        - PolicyName: DynamicEnvVariables
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                Resource:
                  - !Sub "arn:aws:logs:*:${AWS::AccountId}:log-group:/aws/lambda/GenerateCdcView"
              - Effect: Allow
                Action:
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  - !Sub "arn:aws:logs:*:${AWS::AccountId}:log-group:/aws/lambda/GenerateCdcView:*" 

  GenerateCdcViewFunctionPermissions:
    Type: AWS::Lambda::Permission
    Properties:
      Action: "lambda:InvokeFunction"
      FunctionName: !GetAtt GenerateCdcViewFunction.Arn
      Principal: "cloudformation.amazonaws.com"
  
  GenerateCdcViewFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: GenerateCdcView
      Code:
        ZipFile: |
            ##########################################################
            ### hive_parser.py
            ##########################################################

            HiveTypeToken_PUNCTUATION = [ "<", ">", ",", ":" ]
            HiveTypeToken_KEYWORDS = [ "array", "struct" ]
            HiveTypeToken_FIXED_TOKENS = HiveTypeToken_PUNCTUATION + HiveTypeToken_KEYWORDS


            class HiveTypeToken:

              type: str
              value: str
              position: int
              isFixed: bool

              def __init__(self, value, position):
                self.value = value
                self.position = position
                self.isFixed = value in HiveTypeToken_FIXED_TOKENS
                self.type = ("FIXED:" + value) if self.isFixed else "WORD"

              def __str__(self):
                return "Token(type=" + self.type + ",value=" + self.value + ")"


            class HiveTypeTokenizer:

              def __init__( self, hiveTypeStr ):
                self.hiveTypeStr = hiveTypeStr
                self.tokens = []
                position = 0

                self.isInWord = False
                self.currentWordStart = None

                while position < len( hiveTypeStr ):
                  currentChar = hiveTypeStr[ position ]

                  if currentChar.isspace():
                    self.addCurrentWord( position )
                  elif currentChar in HiveTypeToken_PUNCTUATION:
                    self.addCurrentWord( position )
                    self.tokens.append( HiveTypeToken( currentChar, position) )
                  else:
                    # Enter in a word token if not already inside a word token
                    if not self.isInWord:
                      self.isInWord = True
                      self.currentWordStart = position
                  position = position + 1
                self.addCurrentWord( position )


              def addCurrentWord( self, position ):
                if self.isInWord:
                  tokenValue = self.hiveTypeStr[ self.currentWordStart : position ]
                  self.tokens.append( HiveTypeToken( tokenValue, self.currentWordStart) )
                  self.isInWord = False
                  self.currentWordStart = None

              def hasNext(self):
                return len( self.tokens ) > 0

              def topTokenTypeIs( self, type ):
                return self.hasNext() and type == self.tokens[0].type

              def assertTopTokenType( self, type ):
                if not self.topTokenTypeIs( type ):
                  msg = "Empty tokens array" if not self.hasNext() else "Top token type is " + self.tokens[0].type + " instead of " + type
                  raise Exception( msg )

              def assertAndConsumeTopTokenType( self, type ):
                self.assertTopTokenType( type )
                self.next()

              def next( self ):
                t = self.tokens[ 0 ]
                self.tokens.pop(0)
                return t



            class HiveType:

              def __init__(self, category, simpleType, arrayElementType, structChildren):
                self.category = category
                self.simpleType = simpleType
                self.arrayElementType = arrayElementType
                self.structChildren = structChildren
                self.parent = None
                self.positionIntoParent = None

              def getPath( self ):
                if self.parent:
                  result = self.parent.getPath()
                  result.append( self.positionIntoParent )
                else:
                  result = []
                return result

              def sql(self):
                if "SIMPLE" == self.category:
                  result = self.simpleType
                elif "ARRAY" == self.category:
                  result = "array<" + self.arrayElementType.sql() + ">"
                elif "STRUCT" == self.category:
                  fields = [ (key + ":" + self.structChildren[key].sql()) for key in sorted(self.structChildren) ]
                  result = "struct<" + ",".join( fields ) + ">"
                else:
                  raise Exception("category not supported " + self.category)
                return result


            class HiveTypeBuilder:

              category: str
              simpleType: str
              arrayElementType: HiveType
              structChildren: dict[str, HiveType]

              def __init__(self):
                self.category = None
                self.simpleType = None
                self.arrayElementType = None
                self.structChildren = {}


              def setSimpleType( self, typeString ):
                self.category = "SIMPLE"
                self.simpleType = typeString
                return self

              def arrayType( self, elementType ):
                self.category = "ARRAY"
                self.arrayElementType = elementType
                elementType.positionIntoParent = "[*]"
                return self

              def addStructField(  self, fieldName, fieldType ):
                self.category = "STRUCT"
                self.structChildren[ fieldName ] = fieldType
                fieldType.positionIntoParent = fieldName
                return self

              def build( self ):
                ht = HiveType( self.category, self.simpleType, self.arrayElementType, self.structChildren.copy() )
                if self.category == "ARRAY":
                  self.arrayElementType.parent = ht
                elif self.category == "STRUCT":
                  for child in self.structChildren.values():
                    child.parent = ht
                return ht


            class HiveTypeParser:

              def parse( self, typeString ):
                try:
                  tokens = HiveTypeTokenizer( typeString )
                  result = self.parseType( tokens )
                  if tokens.hasNext():
                    t = tokens.next()
                    raise Exception("Expected end of string got " + str(t) )
                  return result
                except Exception as err:
                  tb = err.__traceback__
                  raise Exception( str(err) + "\n SOURCE STRING:\n" + typeString).with_traceback( tb ) from err

              def parseType( self, tokens ):
                typeBuilder = HiveTypeBuilder()

                t = tokens.next()
                if t.type == "FIXED:struct":
                  tokens.assertAndConsumeTopTokenType( "FIXED:<")
                  while not tokens.topTokenTypeIs( "FIXED:>"):
                    tokens.assertTopTokenType( "WORD" )
                    fieldName = tokens.next().value

                    tokens.assertAndConsumeTopTokenType( "FIXED::")
                    fieldType = self.parseType( tokens )

                    typeBuilder.addStructField( fieldName, fieldType )
                    if tokens.topTokenTypeIs( "FIXED:," ):
                      tokens.next()
                    else:
                      tokens.assertTopTokenType( "FIXED:>")
                  tokens.assertAndConsumeTopTokenType( "FIXED:>")

                elif t.type == "FIXED:array":
                  tokens.assertAndConsumeTopTokenType( "FIXED:<")
                  elementType = self.parseType( tokens )
                  typeBuilder.arrayType( elementType )
                  tokens.assertAndConsumeTopTokenType( "FIXED:>")

                elif t.type == "WORD":
                  typeBuilder.setSimpleType( t.value )

                else:
                  raise Exception("Expected array,struct or simple type got" + t)

                return typeBuilder.build()

            class BaseHiveTypeVisitor:

              def __init__( self ):
                pass

              def visit( self, rootHiveType, ctx ):
                nodes = []
                nodes.insert( 0, rootHiveType )

                while len( nodes ) > 0 :
                  ht = nodes.pop(0)

                  descend = self.enterNodeVisit( ht, ctx )
                  if descend:
                    if "SIMPLE" == ht.category:
                      pass
                    elif "STRUCT" == ht.category:
                      for fieldName in reversed(sorted( ht.structChildren.keys() )):
                        fieldType = ht.structChildren[ fieldName ]
                        nodes.insert( 0, fieldType )
                    elif "ARRAY" == ht.category:
                      nodes.insert( 0, ht.arrayElementType )
                    else:
                      raise Exception("unsupported HiveType category " + ht.category)
                  self.exitNodeVisit( ht, ctx )

              def enterNodeVisit( self, ht, ctx):
                return True

              def exitNodeVisit( self, ht, ctx):
                pass


            ##########################################################
            ### cdc_view_generator.py
            ##########################################################

            import re
            
            ARRAY_DESCEND_NAME = "[*]"
            DYNAMODB_NULL_SUFFIX = "NULL"
            DYNAMODB_SUFFIXES = ["S", "N", "BOOL", "L", "M"]
            TABLE_ALIAS = "t"

            class SimplifiedCdcViewGeneratorContext:

              def __init__( self, arrayField, depth ):
                self.arrayField = arrayField
                self.childArrays = {}
                self.fieldAliases = {}
                self.fieldTypes = {}
                self.reverseAliases = {}
                self.depth = depth

              def isContextRootNode( self, ht ):
                return ht.getPath() == self.arrayField

              def _joinPath( self, path ):
                contextualPath = path[ len( self.arrayField ): len(path) ]
                result = ".".join( [ "\"" + el +"\"" for el in contextualPath if not el == ARRAY_DESCEND_NAME ] )
                return result

              def _buildAlias( self, path ):
                contextualPath = path[ len( self.arrayField ) : len(path) ]

                elIsNotADynamoOrArraySuffix = lambda el : not el in DYNAMODB_SUFFIXES and not el == ARRAY_DESCEND_NAME
                result = "_".join( [ el for el in contextualPath if elIsNotADynamoOrArraySuffix(el) ] )
                return self._customizeAlias( result )

              def _customizeAlias( self, originalAlias ):
                if originalAlias.startswith( "dynamodb_NewImage_" ):
                  newAlias = originalAlias[ len("dynamodb_NewImage_") : len(originalAlias)]
                elif originalAlias.startswith( "dynamodb_Keys_" ):
                  newAlias = "dynamodb_keys_" + originalAlias[ len("dynamodb_Keys_") : len(originalAlias)]
                elif originalAlias == "dynamodb_ApproximateCreationDateTime":
                  newAlias = "kinesis_dynamodb_ApproximateCreationDateTime"
                elif originalAlias == "awsregion":
                  newAlias = "stream_awsregion"
                elif originalAlias == "eventid":
                  newAlias = "stream_eventid"
                elif originalAlias == "eventname":
                  newAlias = "stream_eventname"
                elif originalAlias == "useridentity":
                  newAlias = "stream_useridentity"
                elif originalAlias == "recordformat":
                  newAlias = "stream_recordformat"
                elif originalAlias == "tablename":
                  newAlias = "stream_tablename"
                else:
                  newAlias = originalAlias
                return newAlias

              def addAlias( self, path, type):
                if path[ -1 ] != DYNAMODB_NULL_SUFFIX:
                  field = self._joinPath( path )
                  alias = self._buildAlias( path )

                  self.fieldTypes[ field ] = type
                  self.fieldAliases[ field ] = alias
                  if alias not in self.reverseAliases:
                    self.reverseAliases[ alias ] = []
                  self.reverseAliases[ alias ].append( field )
                  #print( str(self.arrayField) + ") ALIAS " + alias + " for " + field + " of type " + type )

              def addArray( self, path ):
                alias = self._buildAlias( path )
                arrayCtx = SimplifiedCdcViewGeneratorContext( path, self.depth + 1 )
                self.childArrays[ alias ] = arrayCtx
                #print( str(self.arrayField) + ") ARRAY as " + alias)
                return arrayCtx

              def getViewQuery( self, tableName, indentationStepSize ):
                indentStep = " " * indentationStepSize

                # Query definition with CTE used for simple where condition writing
                query = "WITH simplified_data AS (\n" \
                      + indentStep + "SELECT\n"

                selectListIndent = indentStep * 2
                propertiesSelectList = self._buildSimplePropertySelectList( selectListIndent )
                arraySelectList = self._buildTransformSelectList( selectListIndent, indentationStepSize )

                query = query + propertiesSelectList
                if not propertiesSelectList.isspace() and not arraySelectList.isspace():
                  query = query + ",\n"
                query = query + arraySelectList + "\n"

                # - End CTE and write query. The caller can add where condition using aliases instead
                #   of value expression
                query = query + indentStep + "FROM\n" \
                      + indentStep + indentStep + tableName + " " + TABLE_ALIAS + "\n" \
                      + ")\n" \
                      + "SELECT\n" \
                      + indentStep + "*\n" \
                      + "FROM\n" \
                      + indentStep + "simplified_data"
                return query

              def getViewColumns( self, arrayKeyword = "array", rowKeyword="row", nameTypeSep=" " ):
                result = []

                for alias in sorted(self.reverseAliases):
                  fields = self.reverseAliases[ alias ]
                  type = self._generateOneNonArrayType( fields )
                  result.append( { "name": alias, "type": type} )

                for alias in sorted( self.childArrays ):
                  childCtx = self.childArrays[ alias ]
                  innerRowType = childCtx._buildOnlySignaturesListForArrayCast("", 0, arrayKeyword, rowKeyword, nameTypeSep)
                  innerRowTypeOnOneLine = re.sub("[ \n]+", " ", innerRowType)
                  type = arrayKeyword + "(" + innerRowTypeOnOneLine + ")"
                  result.append( { "name": alias, "type": type} )
                return result


              def _buildSimplePropertySelectList( self, baseIndent ):
                result = ""
                for alias in sorted( self.reverseAliases ):
                  if result:
                    result = result + ",\n"

                  fields = self.reverseAliases[ alias ]
                  result = result + baseIndent + self._generateOneNonArrayValue( fields ) \
                                  + " AS " + self._wrapAlias( alias )
                return result

              def _buildTransformSelectList( self, baseIndent, indentationStepSize ):
                transformBodyIndent = baseIndent + " " * indentationStepSize

                result = ""
                for alias in sorted( self.childArrays ):
                  if result:
                    result = result + ",\n"
                  childCtx = self.childArrays[ alias ]
                  arrayField = self._joinPath( childCtx.arrayField )
                  arrayElementName = "elem" + str( self.depth )
                  transformBody = childCtx._buildSelectListForArray( arrayElementName, transformBodyIndent, indentationStepSize )
                  result = result + self._writeTransformFunction( baseIndent, arrayField, arrayElementName, transformBody ) \
                        + " AS " + self._wrapAlias( alias )
                return result

              def _buildSelectListForArray( self, arrayElementName, baseIndent, indentationStepSize ):
                innerIndent = baseIndent + " " * indentationStepSize
                values = self._buildOnlyValuesListForArrayCast( arrayElementName, innerIndent, indentationStepSize)
                signatures = self._buildOnlySignaturesListForArrayCast( baseIndent, indentationStepSize)

                result = baseIndent + "cast(row(\n" \
                      + values + "\n" \
                      + baseIndent + ") AS " + signatures + ")"
                return result

              def _buildOnlyValuesListForArrayCast( self, arrayElementName, baseIndent, indentationStepSize ):
                result = ""
                for alias in sorted( self.reverseAliases ):
                  if result:
                    result = result + ",\n"

                  fields = self.reverseAliases[ alias ]
                  fieldWithTransformParam = [ (arrayElementName + "." + f) for f in fields]
                  result = result + baseIndent + self._generateOneNonArrayValue( fieldWithTransformParam )

                for alias in sorted( self.childArrays ):
                  if result:
                    result = result + ",\n"
                  childCtx = self.childArrays[ alias ]
                  arrayField = self._joinPath( childCtx.arrayField )

                  innerArrayElementName = "elem" + str( self.depth )
                  innerIndent = baseIndent + " " * indentationStepSize
                  innerRowCast = childCtx._buildSelectListForArray( innerArrayElementName, innerIndent, indentationStepSize )

                  fullArrayField = arrayElementName + "." + arrayField
                  transformValue = self._writeTransformFunction( baseIndent, fullArrayField, innerArrayElementName, innerRowCast )
                  result = result + transformValue
                return result

              def _buildOnlySignaturesListForArrayCast( self, baseIndent, indentationStepSize, arrayKeyword="array", rowKeyword="row", nameTypeSep=" " ):
                listIndent = baseIndent + " " * indentationStepSize

                result = ""
                for alias in sorted( self.reverseAliases ):
                  if result:
                    result = result + ",\n"

                  fields = self.reverseAliases[ alias ]
                  result = result + listIndent + self._wrapAlias( alias ) + nameTypeSep + self._generateOneNonArrayType( fields )

                for alias in sorted( self.childArrays ):
                  if result:
                    result = result + ",\n"
                  childCtx = self.childArrays[ alias ]

                  innerRowType = childCtx._buildOnlySignaturesListForArrayCast("", 0, arrayKeyword, rowKeyword, nameTypeSep )
                  innerRowTypeOnOneLine = re.sub("[ \n]+", " ", innerRowType)
                  type = arrayKeyword + "(" + innerRowTypeOnOneLine + ")"
                  result = result + listIndent + self._wrapAlias( alias ) + nameTypeSep + type

                return rowKeyword + "(\n" + result + "\n" + baseIndent + ")"

              def _writeTransformFunction( self, baseIndent, arrayField, arrayElementName, transformBody ):
                result = baseIndent + "transform( " + arrayField + ", (" + arrayElementName + ") -> \n" \
                      + transformBody + "\n" \
                      + baseIndent + ")"
                return result

              def _generateOneNonArrayValue( self, fields ):
                if len( fields ) == 1:
                  value = fields[ 0 ]
                else:
                  fieldList = ",".join( fields )
                  value = "coalesce(" + fieldList + ")"
                return value

              def _generateOneNonArrayType( self, fields ):
                if len( fields ) == 1:
                  fieldName = fields[0]
                  type = self.fieldTypes[ fieldName ]
                else:
                  type = "VARCHAR"
                return type

              def _wrapAlias( self, alias ):
                return "\"" + alias + "\""


            class CdcViewGeneratorHiveTypeVisitor( BaseHiveTypeVisitor ):

              def __init__( self, translateToDqlTypes = True):
                self._translateToDqlTypes = translateToDqlTypes

              def enterNodeVisit( self, ht, ctx):
                if not ctx.isContextRootNode( ht ) and ht.category == "ARRAY":
                  childCtx = ctx.addArray( ht.getPath() )
                  self.visit( ht, childCtx )
                  descend = False
                else:
                  descend = True
                return descend

              def exitNodeVisit( self, ht, ctx):
                if ht.category == "SIMPLE":
                  if self._translateToDqlTypes:
                    type = self._ddlType2dqlType( ht.simpleType )
                  else:
                    type = ht.simpleType
                  ctx.addAlias( ht.getPath(), type )

              def getViewQuery( self, hiveType, tableName, indentationStepSize = 4 ):
                rootContext = SimplifiedCdcViewGeneratorContext( [], 0 )
                self.visit( hiveType, rootContext )
                return rootContext.getViewQuery( tableName, indentationStepSize )

              def getViewColumns( self, hiveType, arrayKeyword = "array", rowKeyword = "row", nameTypeSep = " " ):
                rootContext = SimplifiedCdcViewGeneratorContext( [], 0 )
                self.visit( hiveType, rootContext )
                return rootContext.getViewColumns( arrayKeyword, rowKeyword, nameTypeSep )

              def _ddlType2dqlType( self, ddlType ):
                if ddlType == "string":
                  dqlType = "VARCHAR"
                elif ddlType == "long":
                  dqlType = "BIGINT"
                else:
                  dqlType = ddlType.upper()
                return dqlType


            

            ##########################################################
            ### main.py
            ##########################################################
            import json
            import base64

            def buildTableTypeString( keysType, newImageType ):
              return "struct<" + \
                          "awsregion:string," + \
                          "eventid:string," + \
                          "eventname:string," + \
                          "useridentity:string," + \
                          "recordformat:string," + \
                          "tablename:string," + \
                          "p_year:string," + \
                          "p_month:string," + \
                          "p_day:string," + \
                          "p_hour:string," + \
                          "dynamodb:struct<" + \
                              "ApproximateCreationDateTime:bigint," + \
                              "SizeBytes:bigint," + \
                              "Keys:" + keysType + "," + \
                              "NewImage:" + newImageType + \
                          ">" + \
                    ">"

            def fromTypeStringToQuery( tableTypeString, tableName ):
              hiveTypeParser = HiveTypeParser()
              cdcViewGenerator = CdcViewGeneratorHiveTypeVisitor()
              query = cdcViewGenerator.getViewQuery( hiveTypeParser.parse( tableTypeString ), tableName )
              return query

            def buildCdcViewQuery( databaseName, cdcTableName, cdcViewName, keysType, newImageType, filter = "" ):
              fullCdcTableName = "\"" + databaseName + "\".\"" + cdcTableName + "\""
              fullCdcViewName = "\"" + databaseName + "\".\"" + cdcViewName + "\""
              fullTableType = buildTableTypeString( keysType, newImageType )

              query = fromTypeStringToQuery( fullTableType, fullCdcTableName )
              if filter and not filter.isspace():
                query = query + "\nWHERE\n" + " " * 4 + "(" + filter + ")"
              return  query

            def buildCdcViewColumnList( keysType, newImageType, translateToDqlTypes = True ):
              fullTableType = buildTableTypeString( keysType, newImageType )
              hiveTypeParser = HiveTypeParser()
              cdcViewGenerator = CdcViewGeneratorHiveTypeVisitor( translateToDqlTypes )
              if translateToDqlTypes:
                columnsForJson = cdcViewGenerator.getViewColumns( hiveTypeParser.parse( fullTableType ))
              else:
                columnsForJson = cdcViewGenerator.getViewColumns( hiveTypeParser.parse( fullTableType ), "array", "struct", ":" )
                for el in columnsForJson:
                  el["type"] = el["type"].replace("(", "<").replace(")", ">").replace("VARCHAR","string").replace("\"", "").replace(" ", "")
            #    columnsForJson = [ el for el in columnsForJson if not ">" in el["type"] ]
              return columnsForJson

            def buildPrestoViewString( params ):
              originalSql = buildCdcViewQuery( params["DatabaseName"], \
                                      params["CdcTableName"], params["CdcViewName"], \
                                      params["CdcKeysType"], params["CdcNewImageType"], \
                                      params["CdcRecordFilter"] )
              viewData = {}
              viewData["originalSql"] = originalSql
              viewData["catalog"] = params["CatalogName"]
              viewData["schema"] = params["DatabaseName"]
              viewData["columns"] = buildCdcViewColumnList( params["CdcKeysType"], params["CdcNewImageType"] )

              print( "VIEW SQL QUERY:\n" + viewData["originalSql"] )

              viewDataJsonString = json.dumps( viewData )
              print( "VIEW JSON DATA:\n" + viewDataJsonString )

              prestoViewString = "/* Presto View: " + base64.b64encode( viewDataJsonString.encode('utf-8') ).decode('utf-8') + " */"
              print( "CLOUDFORMATION ORIGINAL QUERY:\n" + prestoViewString )
              return prestoViewString

            def buildCloudFormationStorageDescriptorColumns( params ):
              columns = buildCdcViewColumnList( params["CdcKeysType"], params["CdcNewImageType"], False )
              columns = [ { "Name": el["name"], "Type": el["type"] } for el in columns ]
              print( json.dumps( columns ))
              return columns
            

            def lambda_handler(event, context):
              params = event["params"]
              if params["OutputType"] == 'StorageDescriptor-Columns':
                fragmentResult = buildCloudFormationStorageDescriptorColumns( params )
              elif params["OutputType"] == 'ViewOriginalText':
                fragmentResult = buildPrestoViewString( params )
              else:
                raise Exception("output type not supported " + params["OutputType"] )
            
              return {
                "requestId": event["requestId"],
                "fragment": fragmentResult,
                "status": 'success'
              }

      Runtime: python3.12
      Handler: "index.lambda_handler"
      Role: !GetAtt GenerateCdcViewFunctionRole.Arn

